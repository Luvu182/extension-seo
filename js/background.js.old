'use strict';

// --- Enhanced Data Store ---
// Main cache for final tab data with better URL-based indexing
const seoDataStore = {};
// Each tabId now maps to an object with URL keys
// seoDataStore = {
//   tabId1: {
//     'url1': { /* data for url1 */ },
//     'url2': { /* data for url2 */ }
//   },
//   tabId2: { /* ... */ }
// }

// Temporary store for accumulating redirect hops
const redirectChainStore = {};

// Store to track the last known URL for each tab
const lastKnownUrls = {};

// Keep track of update timestamps to handle out-of-order updates
const lastUpdateTimestamps = {};

// --- Helper function to get/set data with URL-based indexing ---
function getTabData(tabId, url) {
  if (!seoDataStore[tabId]) {
    seoDataStore[tabId] = {};
  }

  if (url && !seoDataStore[tabId][url]) {
    seoDataStore[tabId][url] = {};
  }

  return url ? seoDataStore[tabId][url] : seoDataStore[tabId];
}

function setTabData(tabId, url, data) {
  if (!seoDataStore[tabId]) {
    seoDataStore[tabId] = {};
  }

  seoDataStore[tabId][url] = data;

  // Also save to chrome.storage with URL-specific key
  const storageKey = `tab_${tabId}_${encodeURIComponent(url)}`;
  const storageData = {};
  storageData[storageKey] = data;

  chrome.storage.local.set(storageData, () => {
    if (chrome.runtime.lastError) {
      console.error(`[background.js] Error saving data for tab ${tabId}, url ${url}:`, chrome.runtime.lastError);
    } else {
      console.log(`[background.js] Successfully saved data for tab ${tabId}, url ${url}`);
    }
  });
}

// --- Web Request Listeners (Keep for Redirects and Status Code) ---

// --- Web Request Listeners (Keep for Redirects and Status Code) ---
// These remain mostly unchanged but use the new data storage approach

chrome.webRequest.onBeforeRedirect.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;

    // Initialize chain if it doesn't exist for this tab's navigation sequence
    if (!redirectChainStore[tabId]) {
      redirectChainStore[tabId] = [];
    }

    // Add the current hop to the temporary chain store
    redirectChainStore[tabId].push({
      fromUrl: details.url,
      toUrl: details.redirectUrl,
      statusCode: details.statusCode,
      timeStamp: details.timeStamp
    });
    console.log(`[background.js onBeforeRedirect] Added hop to redirectChainStore for tab ${tabId}. Chain length: ${redirectChainStore[tabId].length}`);
  },
  {urls: ["<all_urls>"], types: ["main_frame"]},
  ["responseHeaders"]
);

chrome.webRequest.onCompleted.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;
    const finalUrl = details.url;
    const finalStatusCode = details.statusCode;

    console.log(`[background.js onCompleted] Completed for tab ${tabId}, url ${finalUrl} with status ${finalStatusCode}.`);

    // Get existing data for this tab+URL
    const currentData = getTabData(tabId, finalUrl) || {};
    const redirectChain = redirectChainStore[tabId]; // Get the accumulated chain for this navigation

    // --- Finalize Data ---
    currentData.statusCode = finalStatusCode; // Set the final status

    if (redirectChain && redirectChain.length > 0) {
      // Redirect occurred: Build the definitive redirect object
      const firstHop = redirectChain[0];
      const lastHop = redirectChain[redirectChain.length - 1];
      currentData.redirect = {
        count: redirectChain.length,
        chain: redirectChain,
        statusCode: firstHop.statusCode, // Status of the *first* redirect
        originalRequestedUrl: firstHop.fromUrl, // URL that *caused* the first redirect
        fromUrl: firstHop.fromUrl, // URL that *caused* the first redirect
        toUrl: lastHop.toUrl // Final destination
      };
      currentData.responseDetailStatusCode = firstHop.statusCode; // Detail status is the first redirect's status
      console.log(`[background.js onCompleted] Finalized redirect data for tab ${tabId}, url ${finalUrl}.`);
    } else {
      // No redirect occurred
      delete currentData.redirect; // Ensure no redirect object
      currentData.responseDetailStatusCode = finalStatusCode; // Detail status is the final status
      console.log(`[background.js onCompleted] No redirect detected for tab ${tabId}, url ${finalUrl}.`);
    }

    // Ensure other placeholders exist if sendSEOData hasn't run yet
    if (!currentData.serverInfo) currentData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
    if (!currentData.webVitals) currentData.webVitals = {};

    // Ensure status codes have values (should be set above, but safety check)
    if (currentData.responseDetailStatusCode === undefined) currentData.responseDetailStatusCode = 'N/A';
    if (currentData.statusCode === undefined) currentData.statusCode = 'N/A';

    // --- Save Final Data ---
    console.log(`[background.js onCompleted] Saving final data for tab ${tabId}, url ${finalUrl}`);
    setTabData(tabId, finalUrl, currentData);

    // Update last known URL
    lastKnownUrls[tabId] = finalUrl;

    // Clear the temporary chain store for this tab now that navigation is complete
    delete redirectChainStore[tabId];
  },
  {urls: ["<all_urls>"], types: ["main_frame"]},
  ["responseHeaders"]
);

chrome.webRequest.onErrorOccurred.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;
    const finalUrl = details.url;
    console.log(`[background.js onErrorOccurred] Error for tab ${tabId}, url ${finalUrl}. Status 0.`);

    // Get existing data for this tab+URL
    const currentData = getTabData(tabId, finalUrl) || {};
    const redirectChain = redirectChainStore[tabId];

    // --- Finalize Data with Error ---
    currentData.statusCode = 0; // Final status is error

    if (redirectChain && redirectChain.length > 0) {
      // Redirect started before error
      const firstHop = redirectChain[0];
      const lastHop = redirectChain[redirectChain.length - 1];
      currentData.redirect = {
        count: redirectChain.length,
        chain: redirectChain,
        statusCode: firstHop.statusCode,
        originalRequestedUrl: firstHop.fromUrl,
        fromUrl: firstHop.fromUrl,
        toUrl: lastHop.toUrl // Last known destination
      };
      currentData.responseDetailStatusCode = firstHop.statusCode; // Detail status is the first redirect's
      console.log(`[background.js onErrorOccurred] Finalized redirect data with error for tab ${tabId}, url ${finalUrl}.`);
    } else {
      // Error occurred before any redirect
      delete currentData.redirect;
      currentData.responseDetailStatusCode = 0; // Detail status is error
      console.log(`[background.js onErrorOccurred] No redirect detected before error for tab ${tabId}, url ${finalUrl}.`);
    }

    // Ensure other placeholders exist
    if (!currentData.serverInfo) currentData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
    if (!currentData.webVitals) currentData.webVitals = {};
    if (currentData.responseDetailStatusCode === undefined) currentData.responseDetailStatusCode = 'N/A';
    if (currentData.statusCode === undefined) currentData.statusCode = 'N/A';

    // --- Save Final Error Data ---
    console.log(`[background.js onErrorOccurred] Saving error data for tab ${tabId}, url ${finalUrl}`);
    setTabData(tabId, finalUrl, currentData);

    // Update last known URL
    lastKnownUrls[tabId] = finalUrl;

    // Clear the temporary chain store for this tab now that navigation has errored
    delete redirectChainStore[tabId];
  },
  {urls: ["<all_urls>"], types: ["main_frame"]}
);

// --- Tab Lifecycle Listeners ---

// --- Primary Cleanup Listener for Real Navigations ---
chrome.webNavigation.onBeforeNavigate.addListener((details) => {
  // Filter for main frame navigations and valid URLs
  if (details.frameId === 0 && details.url && (details.url.startsWith('http:') || details.url.startsWith('https:'))) {
    const tabId = details.tabId;
    const newUrl = details.url;
    console.log(`[background.js onBeforeNavigate] Real navigation starting for tab ${tabId} to ${newUrl}. Clearing redirect chain.`);

    // Clear redirect chains
    delete redirectChainStore[tabId];

    // Update last known URL
    lastKnownUrls[tabId] = newUrl;

    // Don't clear seoDataStore completely - we'll keep URL-specific data
    // This helps with back/forward navigation in SPAs

    // Clear only old timestamps
    delete lastUpdateTimestamps[tabId];
  }
});

// Listener for traditional page loads/reloads (Secondary Cleanup)
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  // Only handle 'loading' status for valid URLs to perform cleanup
  if (changeInfo.status === 'loading' && tab.url && (tab.url.startsWith('http:') || tab.url.startsWith('https:'))) {
    const newUrl = tab.url;
    // Check if this 'loading' event corresponds to a *different* URL than the last known one
    // This helps differentiate between a true navigation/reload and potential status flickers
    if (lastKnownUrls[tabId] !== newUrl) {
      console.log(`[background.js onUpdated 'loading'] Page loading detected for tab ${tabId} to new URL ${newUrl}.`);

      // Update last known URL
      lastKnownUrls[tabId] = newUrl;

      // Clear redirect chains
      delete redirectChainStore[tabId];

      // Clear timestamps
      delete lastUpdateTimestamps[tabId];
    } else {
      console.log(`[background.js onUpdated 'loading'] Page loading detected for tab ${tabId}, but URL (${newUrl}) matches last known. Minimal action (clearing redirect chain).`);
      // Only clear the redirect chain in this case, as it might be a simple refresh (F5)
      delete redirectChainStore[tabId];
    }
  }
});

chrome.tabs.onRemoved.addListener((tabId) => {
  // Clear all data associated with the closed tab
  delete seoDataStore[tabId];
  delete redirectChainStore[tabId];
  delete lastKnownUrls[tabId];
  delete lastUpdateTimestamps[tabId];

  // Find and remove all tab-specific storage items
  chrome.storage.local.get(null, (items) => {
    const keysToRemove = Object.keys(items).filter(key => key.startsWith(`tab_${tabId}_`));
    if (keysToRemove.length > 0) {
      chrome.storage.local.remove(keysToRemove, () => {
        console.log(`[background.js onRemoved] Removed ${keysToRemove.length} storage items for closed tab ${tabId}.`);
      });
    }
  });

  console.log(`[background.js onRemoved] Cleared data for closed tab ${tabId}.`);
});

// --- Message Handling ---

chrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {
  // Handle immediate SPA navigation detection notification
  if (message.action === "spa_navigation_detected" && sender.tab) {
    const tabId = sender.tab.id;
    const url = message.url;
    const source = message.source || 'unknown';
    const timestamp = message.timestamp || Date.now();

    console.log(`[background.js] Received SPA navigation notification for tab ${tabId}, URL: ${url}, source: ${source}`);

    // Create temporary data for this URL with SPA flags
    const tempData = {
      url: url,
      isSpaNavigation: true,
      isSpaDetected: true,
      navigationSource: source,
      isLoading: true, // Mark as loading
      statusCode: 'loading', // Placeholder
      timestamp: timestamp,
      partialData: true, // Flag that this is partial data
      waitingForExtraction: true // Flag that full extraction is in progress
    };

    // Store this temporary data
    setTabData(tabId, url, tempData);

    // Update timestamps
    lastUpdateTimestamps[tabId] = timestamp;
    lastKnownUrls[tabId] = url;

    if (sendResponse) sendResponse({ success: true });
    return true;
  }

  // Handle content script extraction errors
  if (message.action === "content_extraction_error" && sender.tab) {
    const tabId = sender.tab.id;
    const url = message.url;
    const error = message.error || "Unknown error during extraction";
    const source = message.source || 'unknown';

    console.error(`[background.js] Received extraction error for tab ${tabId}, URL: ${url}: ${error}`);

    // Update the data with error info
    const existingData = getTabData(tabId, url) || {};
    existingData.error = error;
    existingData.extractionFailed = true;
    existingData.navigationSource = source;
    existingData.timestamp = message.timestamp || Date.now();
    existingData.isLoading = false; // No longer loading
    existingData.partialData = true; // Still partial data

    // Store the updated data
    setTabData(tabId, url, existingData);

    if (sendResponse) sendResponse({ success: true });
    return true;
  }

  // --- Store data from content script with enhanced SPA support ---
  if (message.action === "content_update" && sender.tab && message.data) {
    const tabId = sender.tab.id;
    const incomingUrl = message.data.url; // URL sent by content script
    const source = message.source || 'unknown'; // Where the update came from
    const timestamp = message.timestamp || Date.now(); // When the update was sent
    const isSpaNavigation = message.data.isSpaNavigation || false; // Check for SPA navigation flag

    if (!tabId || !incomingUrl) {
      console.warn("[background.js] Invalid content_update message:", message);
      if (sendResponse) sendResponse({ success: false, error: "Invalid message" });
      return;
    }

    // Log SPA navigation events more prominently
    if (isSpaNavigation) {
      console.log(`[background.js] Received SPA navigation update for tab ${tabId}, source: ${source}, URL: ${incomingUrl}`);
    }

    // Check for out-of-order updates - bypass this check for SPA navigation to ensure data gets updated
    if (!isSpaNavigation && lastUpdateTimestamps[tabId] && timestamp < lastUpdateTimestamps[tabId]) {
      console.warn(`[background.js] Received outdated update for tab ${tabId} (${source}). Ignoring.`);
      if (sendResponse) sendResponse({ success: false, error: "Outdated update" });
      return;
    }

    // Update the timestamp
    lastUpdateTimestamps[tabId] = timestamp;

    // Update last known URL
    lastKnownUrls[tabId] = incomingUrl;

    // Get existing data or create a new entry
    const existingData = getTabData(tabId, incomingUrl) || {};

    // Merge content script data, preserving background-captured status/redirect/vitals/server
    const mergedData = {
      ...message.data, // Start with fresh content data (including URL)
      // Explicitly keep existing background data if present
      ...(existingData.statusCode !== undefined && existingData.statusCode !== 'loading' && { statusCode: existingData.statusCode }),
      ...(existingData.responseDetailStatusCode !== undefined && { responseDetailStatusCode: existingData.responseDetailStatusCode }),
      ...(existingData.redirect && { redirect: existingData.redirect }),
      ...(existingData.webVitals && { webVitals: existingData.webVitals }),
      ...(existingData.serverInfo && { serverInfo: existingData.serverInfo }),
      // Preserve SPA flags if present in either existing data or incoming data
      ...(existingData.isSpaNavigation && { isSpaNavigation: true }),
      ...(existingData.navigationSource && { navigationSource: existingData.navigationSource }),
      // Clear any loading or partial data flags
      isLoading: false,
      partialData: false,
      waitingForExtraction: false,
      extractionFailed: false,
      // Set time when data was fully extracted
      extractionCompleted: Date.now(),
      // If incoming data has SPA flags, they'll already be included from ...message.data above
      // Add source and timestamp info for debugging
      lastUpdate: {
        source: source,
        timestamp: timestamp,
        date: new Date(timestamp).toISOString(),
        wasSpaNavigation: message.data.isSpaNavigation || false
      }
    };

    // Ensure the background data takes precedence if both exist (redundant safety)
    if (existingData.statusCode !== undefined) mergedData.statusCode = existingData.statusCode;
    if (existingData.responseDetailStatusCode !== undefined) mergedData.responseDetailStatusCode = existingData.responseDetailStatusCode;
    if (existingData.redirect) mergedData.redirect = existingData.redirect;
    if (existingData.webVitals) mergedData.webVitals = existingData.webVitals;
    if (existingData.serverInfo) mergedData.serverInfo = existingData.serverInfo;

    // Ensure placeholders if still missing after merge
    if (mergedData.responseDetailStatusCode === undefined) mergedData.responseDetailStatusCode = 'N/A';
    if (mergedData.statusCode === undefined) mergedData.statusCode = 'N/A';
    if (!mergedData.serverInfo) mergedData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
    if (!mergedData.webVitals) mergedData.webVitals = {};

    console.log(`[background.js content_update] Storing data for tab ${tabId} URL ${incomingUrl} from ${source}`);
    setTabData(tabId, incomingUrl, mergedData);

    // Respond to confirm receipt if callback provided
    if (sendResponse) {
      sendResponse({ success: true });
    }

    return true; // Keep channel open for async response
  }

  // --- Get SEO data for popup (Enhanced for SPAs) ---
  if (message.action === "getSEOData") {
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      if (!tabs || !tabs.length || !tabs[0].id) {
        sendResponse({ success: false, error: "No active tab found" });
        return;
      }

      const tabId = tabs[0].id;
      const tabUrl = tabs[0].url;

      if (!tabUrl || !(tabUrl.startsWith('http:') || tabUrl.startsWith('https:'))) {
        sendResponse({ success: false, error: "Tab URL is not supported" });
        return;
      }

      console.log(`[background.js getSEOData] Retrieving data for tab ${tabId}, url ${tabUrl}`);

      // Try to get data for the current URL first
      let tabData = getTabData(tabId, tabUrl);
      const lastKnownUrl = lastKnownUrls[tabId];

      // If current URL doesn't match lastKnownUrl, that's a potential URL change
      const urlChanged = lastKnownUrl && lastKnownUrl !== tabUrl;

      // If URL has changed but we have no data for the new URL
      if (urlChanged && !tabData) {
        console.log(`[background.js getSEOData] URL has changed from ${lastKnownUrl} to ${tabUrl}`);

        // Return special object indicating URL change
        sendResponse({
          success: true,
          data: {
            urlChanged: true,
            oldUrl: lastKnownUrl,
            newUrl: tabUrl,
            needsRefresh: true,
            isSpaDetected: true
          }
        });

        // Update lastKnownUrl to current URL
        lastKnownUrls[tabId] = tabUrl;
        return;
      }

      // If no data for current URL, try the lastKnownUrl as fallback
      if (!tabData && lastKnownUrl && lastKnownUrl !== tabUrl) {
        console.log(`[background.js getSEOData] No data for current URL, trying last known URL: ${lastKnownUrl}`);
        tabData = getTabData(tabId, lastKnownUrl);
      }

      // Check if we have any data, even if it's partial/loading
      if (tabData) {
        // If data exists but is waiting for extraction, mark it as partial
        if (tabData.waitingForExtraction || tabData.isLoading) {
          console.log(`[background.js getSEOData] Found partial data for tab ${tabId}, marked as loading`);
          tabData.partialData = true;
          tabData.isLoadingSpa = true;

          // If this is a new SPA detection with no real data yet, mark it specially
          if (!tabData.title && tabData.isSpaDetected) {
            tabData.freshSpaNavigation = true;
          }
        }
        // If extraction failed, mark it as error
        else if (tabData.extractionFailed) {
          console.log(`[background.js getSEOData] Found data with extraction failure for tab ${tabId}`);
          tabData.error = tabData.error || "Failed to extract data from page";
        }

        console.log(`[background.js getSEOData] Returning data for tab ${tabId}, partial: ${!!tabData.partialData}`);
        sendResponse({ success: true, data: tabData });
        return;
      }

      // If not in memory, check storage with fallback strategy
      const storageKey = `tab_${tabId}_${encodeURIComponent(tabUrl)}`;
      chrome.storage.local.get(storageKey, function(result) {
        if (result[storageKey]) {
          // Found in storage for current URL
          console.log(`[background.js getSEOData] Found data in storage for tab ${tabId}, url ${tabUrl}`);
          const retrievedData = result[storageKey];

          // Cache in memory
          setTabData(tabId, tabUrl, retrievedData);

          sendResponse({ success: true, data: retrievedData });
        } else if (lastKnownUrls[tabId] && lastKnownUrls[tabId] !== tabUrl) {
          // Try last known URL in storage
          const fallbackKey = `tab_${tabId}_${encodeURIComponent(lastKnownUrls[tabId])}`;
          chrome.storage.local.get(fallbackKey, function(fallbackResult) {
            if (fallbackResult[fallbackKey]) {
              console.log(`[background.js getSEOData] Found data for last known URL: ${lastKnownUrls[tabId]}`);
              sendResponse({ success: true, data: fallbackResult[fallbackKey] });
            } else {
              // Nothing found, send null data
              console.log(`[background.js getSEOData] No data found for tab ${tabId}`);
              sendResponse({ success: true, data: null });
            }
          });
          return true; // Keep channel open for async response
        } else {
          // No last known URL or matches current URL, send null
          console.log(`[background.js getSEOData] No data found for tab ${tabId}`);
          sendResponse({ success: true, data: null });
        }
      });

      return true; // Keep channel open for async response
    });

    return true; // Keep channel open for tabs.query async response
  }

  // --- Fetch Server Details on Demand ---
  if (message.action === "fetchServerDetails") {
    chrome.tabs.query({active: true, currentWindow: true}, async function(tabs) {
      if (tabs && tabs.length > 0 && tabs[0].id) {
        const tabId = tabs[0].id;
        const currentTab = tabs[0];
        const currentUrl = currentTab.url;
        let serverInfoResult = { ip: 'N/A (API Error)', httpVersion: 'N/A', server: 'N/A', loaded: true };

        if (currentUrl && (currentUrl.startsWith('http:') || currentUrl.startsWith('https:'))) {
          try {
            const url = new URL(currentUrl);
            const targetDomain = url.hostname;
            const backendApiUrl = 'https://vercel-extension-backend.vercel.app/api/check-server';
            const response = await fetch(backendApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ target: targetDomain })
             });
             if (!response.ok) throw new Error(`Backend API HTTP error! status: ${response.status}`);
             const backendData = await response.json();
             if (backendData.success) {
               serverInfoResult = {
                 ip: backendData.dns_info?.main_ip || 'N/A (No IP)',
                 httpVersion: backendData.http_info?.highest_version || 'N/A',
                 server: backendData.http_info?.server || 'N/A',
                 loaded: true
               };
               // Update stored data
               const currentData = getTabData(tabId, currentUrl) || {};
               currentData.serverInfo = serverInfoResult;
               setTabData(tabId, currentUrl, currentData);
               console.log(`[fetchServerDetails] Saved server info for tab ${tabId}, url ${currentUrl}`);
              } else {
               console.warn(`[fetchServerDetails] Backend API failure:`, backendData);
               serverInfoResult.ip = `N/A (Backend: ${backendData.error || 'Failed'})`;
             }
          } catch (error) {
            console.error(`[fetchServerDetails] Error fetching backend API:`, error);
            serverInfoResult.ip = 'N/A (Fetch Error)';
          }
        } else {
           serverInfoResult.ip = 'N/A (Invalid URL)';
        }
        sendResponse({ success: true, serverInfo: serverInfoResult });
      } else {
        sendResponse({ success: false, error: "No active tab found" });
      }
    });
    return true;
  }

  // --- Inject Web Vitals Library ---
  if (message.action === "injectWebVitals") {
    const tabId = sender.tab?.id;
    if (!tabId) return sendResponse({ success: false, error: "No sender tab ID" });
    console.log(`[background.js] Received injectWebVitals request for tab ${tabId}`);
    (async () => {
      try {
        await chrome.scripting.executeScript({ target: { tabId: tabId }, files: ['js/lib/web-vitals.iife.js'], world: 'ISOLATED' });
        console.log(`[background.js] Injected web-vitals library for tab ${tabId}`);
        sendResponse({ success: true });
      } catch (error) {
        console.error(`[background.js] Failed to inject web-vitals library for tab ${tabId}:`, error);
        sendResponse({ success: false, error: error.message });
      }
    })();
    return true;
  }

  // --- Store Web Vitals Result ---
  if (message.action === "webVitalsResult" && sender.tab && message.data) {
    const tabId = sender.tab.id;
    const { name, value } = message.data;
    const tabUrl = sender.tab.url; // Get the current URL of the tab that sent the metric

    if (tabId && name && typeof value === 'number' && tabUrl) {
      console.log(`[background.js] Received webVitalsResult for tab ${tabId}, url ${tabUrl}:`, name, value);

      // Get current tab data for this specific URL
      const currentData = getTabData(tabId, tabUrl) || {};

      // Initialize webVitals object if needed
      if (!currentData.webVitals) {
        currentData.webVitals = {
          // Initialize with undefined values for all metrics
          lcp: undefined,
          cls: undefined,
          fid: undefined,
          ttfb: undefined
        };
      }

      // Store the web vital metric
      // Use standardized lowercase names for consistent access
      const normalizedName = name.toLowerCase();
      currentData.webVitals[normalizedName] = value;

      // Log the entire webVitals object for debugging
      console.log(`[background.js] Updated webVitals object for tab ${tabId}:`, JSON.stringify(currentData.webVitals));

      // Save updated data
      setTabData(tabId, tabUrl, currentData);
      console.log(`[background.js] Successfully saved web vital ${normalizedName} for tab ${tabId}, url ${tabUrl}`);

      // Notify popup if it's open - this helps update the UI immediately
      try {
        chrome.runtime.sendMessage({
          action: "webVitalsUpdated",
          tabId: tabId,
          url: tabUrl,
          webVitals: currentData.webVitals
        }, function(response) {
          if (chrome.runtime.lastError) {
            // Popup might not be open, this is normal
            console.log(`[background.js] Could not notify popup (expected): ${chrome.runtime.lastError.message}`);
          } else if (response) {
            console.log(`[background.js] Popup acknowledged web vitals update: ${response.success}`);
          }
        });
      } catch (error) {
        // This catch block handles unexpected errors
        console.log(`[background.js] Error notifying popup about webVitals update: ${error.message}`);
      }
    } else {
      console.warn("[background.js] Invalid webVitalsResult message:", message);
    }

    return true; // Keep message channel open for async response
  }

  // --- Check Link Status ---
  if (message.action === "checkLinkStatus") {
    const url = message.url;

    if (!url) {
      sendResponse({ success: false, error: "No URL provided" });
      return true;
    }

    console.log(`[background.js] Checking link status for URL: ${url}`);

    // Create a more robust link checking approach
    // First try with XMLHttpRequest which can handle redirects better
    const xhr = new XMLHttpRequest();

    // Set a timeout to avoid hanging
    const timeoutMs = 5000;
    let isResolved = false;

    // Create a timeout handler
    const timeout = setTimeout(() => {
      if (!isResolved) {
        xhr.abort();
        console.log(`[background.js] Request timeout for ${url}`);
        // Try with fetch as fallback
        tryFetchFallback();
      }
    }, timeoutMs);

    // Function to try fetch as fallback
    const tryFetchFallback = () => {
      console.log(`[background.js] Trying fetch fallback for ${url}`);

      // Try with fetch and no-cors as last resort
      fetch(url, { method: 'HEAD', mode: 'no-cors' })
        .then(response => {
          isResolved = true;
          // With no-cors, we can't see the actual status, so we assume it's available
          console.log(`[background.js] Fetch fallback for ${url}: assuming available`);
          sendResponse({
            success: true,
            status: 'available',
            statusCode: 200 // Assume success
          });
        })
        .catch(fetchError => {
          isResolved = true;
          console.error(`[background.js] All methods failed for ${url}:`, fetchError);
          sendResponse({
            success: false,
            status: 'error',
            statusCode: null,
            error: fetchError.message
          });
        });
    };

    // Set up XHR
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) { // Request completed
        clearTimeout(timeout);
        isResolved = true;

        // Check if we got a redirect
        const finalUrl = xhr.responseURL;
        const isRedirect = finalUrl && finalUrl !== url;

        if (isRedirect) {
          console.log(`[background.js] Detected redirect from ${url} to ${finalUrl}`);
          sendResponse({
            success: true,
            status: 'redirect',
            statusCode: 301, // Assume 301 for redirects
            redirectUrl: finalUrl
          });
          return;
        }

        // Handle normal response
        if (xhr.status) {
          console.log(`[background.js] Status check for ${url}: ${xhr.status}`);
          sendResponse({
            success: true,
            status: xhr.statusText || (xhr.status >= 300 && xhr.status < 400 ? 'redirect' :
                     xhr.status >= 400 && xhr.status < 500 ? 'client error' :
                     xhr.status >= 500 ? 'server error' : 'ok'),
            statusCode: xhr.status
          });
        } else {
          // If we got no status but no error either, try fetch fallback
          tryFetchFallback();
        }
      }
    };

    xhr.onerror = function(error) {
      clearTimeout(timeout);
      console.log(`[background.js] XHR error for ${url}, trying fetch fallback`);
      tryFetchFallback();
    };

    try {
      xhr.open('HEAD', url, true);
      xhr.send();
    } catch (error) {
      clearTimeout(timeout);
      console.error(`[background.js] Error initiating XHR for ${url}:`, error);
      tryFetchFallback();
    }

    return true; // Keep message channel open for async response
  }
});

// --- Periodic cleanup to prevent memory leaks ---
setInterval(() => {
  const MAX_URLS_PER_TAB = 20; // Maximum number of URLs to keep per tab
  const MAX_AGE_MS = 30 * 60 * 1000; // 30 minutes

  for (const tabId in seoDataStore) {
    const urlsForTab = Object.keys(seoDataStore[tabId]);

    // Skip tabs with few URLs
    if (urlsForTab.length <= MAX_URLS_PER_TAB) continue;

    console.log(`[background.js cleanup] Tab ${tabId} has ${urlsForTab.length} URLs. Cleaning up old data.`);

    // Collect URLs with timestamps
    const urlsWithTimestamps = urlsForTab.map(url => {
      const data = seoDataStore[tabId][url];
      const timestamp = data.lastUpdate?.timestamp || 0;
      return { url, timestamp };
    });

    // Sort by timestamp, oldest first
    urlsWithTimestamps.sort((a, b) => a.timestamp - b.timestamp);

    // Keep only the most recent URLs, delete the oldest ones
    const urlsToRemove = urlsWithTimestamps.slice(0, urlsWithTimestamps.length - MAX_URLS_PER_TAB).map(item => item.url);

    // Remove from memory and storage
    for (const url of urlsToRemove) {
      console.log(`[background.js cleanup] Removing old data for tab ${tabId}, url ${url}`);
      delete seoDataStore[tabId][url];

      // Also remove from storage
      const storageKey = `tab_${tabId}_${encodeURIComponent(url)}`;
      chrome.storage.local.remove(storageKey);
    }
  }
}, 10 * 60 * 1000); // Run cleanup every 10 minutes
