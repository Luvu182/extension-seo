'use strict';

// Background script with persistent storage
const seoDataStore = {}; // Main cache for final tab data
const redirectChainStore = {}; // TEMPORARY store for accumulating redirect hops {fromUrl, toUrl, statusCode, timeStamp}
const lastKnownUrls = {}; // Store the last known URL for each tab to detect SPA navigation

// --- Web Request Listeners (Keep for Redirects and Status Code) ---

chrome.webRequest.onBeforeRedirect.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;
    // Initialize chain if it doesn't exist for this tab's navigation sequence
    if (!redirectChainStore[tabId]) {
      redirectChainStore[tabId] = [];
    }

    // Add the current hop to the temporary chain store
    redirectChainStore[tabId].push({
      fromUrl: details.url,
      toUrl: details.redirectUrl,
      statusCode: details.statusCode,
      timeStamp: details.timeStamp
    });
    console.log(`[background.js onBeforeRedirect] Added hop to redirectChainStore for tab ${tabId}. Chain length: ${redirectChainStore[tabId].length}`);

    // DO NOT modify seoDataStore or chrome.storage here. Wait for completion.
  },
  {urls: ["<all_urls>"], types: ["main_frame"]},
  ["responseHeaders"]
);

chrome.webRequest.onCompleted.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;
    const finalStatusCode = details.statusCode;
    console.log(`[background.js onCompleted] Completed for tab ${tabId} with final status ${finalStatusCode}.`);

    // Retrieve data potentially added by sendSEOData earlier in the lifecycle
    const currentData = seoDataStore[tabId] || {};
    const redirectChain = redirectChainStore[tabId]; // Get the accumulated chain for this navigation

    // --- Finalize Data ---
    currentData.statusCode = finalStatusCode; // Set the final status

    if (redirectChain && redirectChain.length > 0) {
      // Redirect occurred: Build the definitive redirect object
      const firstHop = redirectChain[0];
      const lastHop = redirectChain[redirectChain.length - 1];
      currentData.redirect = {
        count: redirectChain.length,
        chain: redirectChain,
        statusCode: firstHop.statusCode, // Status of the *first* redirect
        originalRequestedUrl: firstHop.fromUrl, // URL that *caused* the first redirect
        fromUrl: firstHop.fromUrl, // URL that *caused* the first redirect
        toUrl: lastHop.toUrl // Final destination
      };
      currentData.responseDetailStatusCode = firstHop.statusCode; // Detail status is the first redirect's status
      console.log(`[background.js onCompleted] Finalized redirect data for tab ${tabId}.`);
    } else {
      // No redirect occurred
      delete currentData.redirect; // Ensure no redirect object
      currentData.responseDetailStatusCode = finalStatusCode; // Detail status is the final status
      console.log(`[background.js onCompleted] No redirect detected for tab ${tabId}.`);
    }

    // Ensure other placeholders exist if sendSEOData hasn't run yet
    if (!currentData.serverInfo) currentData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
    if (!currentData.webVitals) currentData.webVitals = {};
    // Ensure status codes have values (should be set above, but safety check)
    if (currentData.responseDetailStatusCode === undefined) currentData.responseDetailStatusCode = 'N/A';
    if (currentData.statusCode === undefined) currentData.statusCode = 'N/A';

    // --- Save Final Data ---
    console.log(`[background.js onCompleted] Saving final data object for tab ${tabId}:`, JSON.stringify(currentData, null, 2));
    seoDataStore[tabId] = currentData; // Update cache
    const storageData = {};
    storageData[`tab_${tabId}`] = currentData;
    chrome.storage.local.set(storageData, () => {
      if (!chrome.runtime.lastError) {
        console.log(`[background.js onCompleted] Successfully saved final data for tab ${tabId}`);
      } else {
        console.error(`[background.js onCompleted] Error saving final data for tab ${tabId}:`, chrome.runtime.lastError);
      }
    });

    // Clear the temporary chain store for this tab now that navigation is complete
    // delete redirectChainStore[tabId]; // Let onUpdated handle clearing on next navigation
  },
  {urls: ["<all_urls>"], types: ["main_frame"]},
  ["responseHeaders"] // Need responseHeaders to potentially get Location for 3xx
);

chrome.webRequest.onErrorOccurred.addListener(
  function(details) {
    if (details.type !== 'main_frame') return;
    const tabId = details.tabId;
    console.log(`[background.js onErrorOccurred] Error for tab ${tabId}. Status 0.`);

    const currentData = seoDataStore[tabId] || {};
    const redirectChain = redirectChainStore[tabId];

    // --- Finalize Data with Error ---
    currentData.statusCode = 0; // Final status is error

    if (redirectChain && redirectChain.length > 0) {
      // Redirect started before error
      const firstHop = redirectChain[0];
      const lastHop = redirectChain[redirectChain.length - 1];
      currentData.redirect = {
        count: redirectChain.length,
        chain: redirectChain,
        statusCode: firstHop.statusCode,
        originalRequestedUrl: firstHop.fromUrl,
        fromUrl: firstHop.fromUrl,
        toUrl: lastHop.toUrl // Last known destination
      };
      currentData.responseDetailStatusCode = firstHop.statusCode; // Detail status is the first redirect's
      console.log(`[background.js onErrorOccurred] Finalized redirect data with error for tab ${tabId}.`);
    } else {
      // Error occurred before any redirect
      delete currentData.redirect;
      currentData.responseDetailStatusCode = 0; // Detail status is error
      console.log(`[background.js onErrorOccurred] No redirect detected before error for tab ${tabId}.`);
    }

    // Ensure other placeholders exist
    if (!currentData.serverInfo) currentData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
    if (!currentData.webVitals) currentData.webVitals = {};
    if (currentData.responseDetailStatusCode === undefined) currentData.responseDetailStatusCode = 'N/A';
    if (currentData.statusCode === undefined) currentData.statusCode = 'N/A';


    // --- Save Final Error Data ---
    console.log(`[background.js onErrorOccurred] Saving final error data object for tab ${tabId}:`, JSON.stringify(currentData, null, 2));
    seoDataStore[tabId] = currentData; // Update cache
    const storageData = {};
    storageData[`tab_${tabId}`] = currentData;
    chrome.storage.local.set(storageData, () => {
        if (chrome.runtime.lastError) {
             console.error(`[background.js onErrorOccurred] Error saving error data for tab ${tabId}:`, chrome.runtime.lastError);
        }
    });

    // Clear the temporary chain store for this tab now that navigation has errored
    // delete redirectChainStore[tabId]; // Let onUpdated handle clearing on next navigation
  },
  {urls: ["<all_urls>"], types: ["main_frame"]}
);

// --- Tab Lifecycle Listeners ---

// REMOVED chrome.webNavigation.onHistoryStateUpdated listener - Replaced by proactive content script

// --- Primary Cleanup Listener for Real Navigations ---
chrome.webNavigation.onBeforeNavigate.addListener((details) => {
  // Filter for main frame navigations and valid URLs
  if (details.frameId === 0 && details.url && (details.url.startsWith('http:') || details.url.startsWith('https:'))) {
    const tabId = details.tabId;
    const newUrl = details.url;
    console.log(`[background.js onBeforeNavigate] Real navigation starting for tab ${tabId} to ${newUrl}. Clearing all data.`);

    // Clear in-memory caches
    delete seoDataStore[tabId];
    delete redirectChainStore[tabId];
    lastKnownUrls[tabId] = newUrl; // Update last known URL immediately

    // Remove stored data for this tab to invalidate it completely
    chrome.storage.local.remove(`tab_${tabId}`, () => {
        if (chrome.runtime.lastError) {
            console.error(`[background.js onBeforeNavigate] Error removing storage data for tab ${tabId}:`, chrome.runtime.lastError);
        } else {
            console.log(`[background.js onBeforeNavigate] Removed storage data for tab ${tabId}.`);
        }
    });
  }
});

// Listener for traditional page loads/reloads (Secondary Cleanup)
chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  // Only handle 'loading' status for valid URLs to perform cleanup
  if (changeInfo.status === 'loading' && tab.url && (tab.url.startsWith('http:') || tab.url.startsWith('https:'))) {
    const newUrl = tab.url;
    // Check if this 'loading' event corresponds to a *different* URL than the last known one
    // This helps differentiate between a true navigation/reload and potential status flickers
    if (lastKnownUrls[tabId] !== newUrl) {
        console.log(`[background.js onUpdated 'loading'] Page loading detected for tab ${tabId} to new URL ${newUrl}. Clearing data.`);

        // Perform the same cleanup as onBeforeNavigate
        delete seoDataStore[tabId];
        delete redirectChainStore[tabId];
        lastKnownUrls[tabId] = newUrl; // Update last known URL

        // Remove stored data
        chrome.storage.local.remove(`tab_${tabId}`, () => {
            if (chrome.runtime.lastError) {
                console.error(`[background.js onUpdated 'loading'] Error removing storage data for tab ${tabId}:`, chrome.runtime.lastError);
            } else {
                console.log(`[background.js onUpdated 'loading'] Removed storage data for tab ${tabId}.`);
            }
        });
    } else {
         console.log(`[background.js onUpdated 'loading'] Page loading detected for tab ${tabId}, but URL (${newUrl}) matches last known. Minimal action (clearing redirect chain).`);
         // Only clear the redirect chain in this case, as it might be a simple refresh (F5)
         delete redirectChainStore[tabId];
    }
  }
});


chrome.tabs.onRemoved.addListener((tabId) => {
  // Clear all data associated with the closed tab
  delete seoDataStore[tabId];
  delete redirectChainStore[tabId];
  chrome.storage.local.remove(`tab_${tabId}`);
  delete lastKnownUrls[tabId]; // Clear last known URL for the removed tab
  console.log(`[background.js onRemoved] Cleared data for closed tab ${tabId}.`);
});

// --- Message Handling ---

chrome.runtime.onMessage.addListener(function(message, sender, sendResponse) {

  // --- Store data from content script (NEW HANDLER) ---
  if (message.action === "content_update" && sender.tab && message.data) {
    const tabId = sender.tab.id;
    const incomingUrl = message.data.url; // URL sent by content script

    if (tabId && incomingUrl) {
      // Check if this update is for the current known URL for the tab
      // This prevents processing stale updates if a real navigation happened concurrently
      if (lastKnownUrls[tabId] && lastKnownUrls[tabId] !== incomingUrl) {
        console.warn(`[background.js content_update] Received update for tab ${tabId} with URL ${incomingUrl}, but last known URL is ${lastKnownUrls[tabId]}. Discarding stale update.`);
        return; // Discard stale update
      }

      // Update last known URL if it wasn't set or matches
      lastKnownUrls[tabId] = incomingUrl;

      // Get existing data (potentially finalized by onCompleted/onError or previous updates)
      const existingData = seoDataStore[tabId] || {};

      // Merge content script data, preserving background-captured status/redirect/vitals/server
      const mergedData = {
        ...message.data, // Start with fresh content data (including URL)
        // Explicitly keep existing background data if present
        ...(existingData.statusCode !== undefined && { statusCode: existingData.statusCode }),
        ...(existingData.responseDetailStatusCode !== undefined && { responseDetailStatusCode: existingData.responseDetailStatusCode }),
        ...(existingData.redirect && { redirect: existingData.redirect }),
        ...(existingData.webVitals && { webVitals: existingData.webVitals }),
        ...(existingData.serverInfo && { serverInfo: existingData.serverInfo })
      };
      // Ensure the background data takes precedence if both exist (redundant safety)
      if (existingData.statusCode !== undefined) mergedData.statusCode = existingData.statusCode;
      if (existingData.responseDetailStatusCode !== undefined) mergedData.responseDetailStatusCode = existingData.responseDetailStatusCode;
      if (existingData.redirect) mergedData.redirect = existingData.redirect;
      if (existingData.webVitals) mergedData.webVitals = existingData.webVitals;
      if (existingData.serverInfo) mergedData.serverInfo = existingData.serverInfo;

      // Ensure placeholders if still missing after merge
      if (mergedData.responseDetailStatusCode === undefined) mergedData.responseDetailStatusCode = 'N/A';
      if (mergedData.statusCode === undefined) mergedData.statusCode = 'N/A';
      if (!mergedData.serverInfo) mergedData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
      if (!mergedData.webVitals) mergedData.webVitals = {};

      console.log(`[background.js content_update] Storing merged data for tab ${tabId} URL ${incomingUrl}:`, JSON.stringify(mergedData, null, 2));
      seoDataStore[tabId] = mergedData; // Update cache

      // Save merged data
      const storageData = {};
      storageData[`tab_${tabId}`] = mergedData;
      chrome.storage.local.set(storageData, () => {
           if (!chrome.runtime.lastError) {
                console.log(`[background.js content_update] Successfully saved merged data for tab ${tabId}`);
            } else {
                 console.error(`[background.js content_update] Error saving merged data to storage for tab ${tabId}:`, chrome.runtime.lastError);
            }
      });
    } else {
        console.warn("[background.js] Invalid content_update message:", message);
    }
    return; // Indicate async handling or no response needed
  }
  // --- REMOVED old "sendSEOData" handler ---

  // --- Get initial SEO data for popup (Retrieval logic remains similar) ---
  if (message.action === "getSEOData") {
    chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
      if (tabs && tabs.length > 0 && tabs[0].id) {
        const tabId = tabs[0].id;

        const retrieveAndSendData = () => {
          const processDataAndSend = (retrievedData) => {
            // If retrievedData is null (meaning storage was empty), send null
            if (retrievedData === null) {
              console.log(`[background.js getSEOData] Sending null data to popup for tab ${tabId}.`);
              sendResponse({ success: true, data: null });
              return;
            }

            // Start with retrieved data or an empty object if none exists (shouldn't happen if null check passes)
            let dataToSend = retrievedData ? JSON.parse(JSON.stringify(retrievedData)) : {};

            // Ensure essential placeholders exist if data is minimal/missing
            if (dataToSend.responseDetailStatusCode === undefined) dataToSend.responseDetailStatusCode = 'N/A';
            if (dataToSend.statusCode === undefined) dataToSend.statusCode = 'N/A';
            dataToSend.serverInfo = dataToSend.serverInfo || { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
            dataToSend.webVitals = dataToSend.webVitals || {};

            console.log(`[background.js getSEOData] Sending data to popup for tab ${tabId}:`, JSON.stringify(dataToSend, null, 2));
            sendResponse({ success: true, data: dataToSend });
          };

          // --- Prioritize checking redirectChainStore for early redirect info ---
          const redirectChain = redirectChainStore[tabId];
          if (redirectChain && redirectChain.length > 0) {
              console.log(`[background.js getSEOData] Found active redirect chain for tab ${tabId}. Reconstructing initial state.`);
              const reconstructedData = {};
              const firstHop = redirectChain[0];
              reconstructedData.redirect = {
                  count: redirectChain.length,
                  chain: redirectChain,
                  statusCode: firstHop.statusCode,
                  originalRequestedUrl: firstHop.fromUrl,
                  fromUrl: firstHop.fromUrl,
                  toUrl: redirectChain[redirectChain.length - 1].toUrl
              };
              reconstructedData.responseDetailStatusCode = firstHop.statusCode;
              reconstructedData.statusCode = 'N/A'; // Final status still unknown
              reconstructedData.serverInfo = { ip: 'N/A', httpVersion: 'N/A', server: 'N/A', loaded: false };
              reconstructedData.webVitals = {};
              processDataAndSend(reconstructedData);
              return; // Sent reconstructed data, exit early
          }

          // --- If no active redirect chain, check cache and storage for finalized data ---
          if (seoDataStore[tabId]) {
            console.log(`[background.js getSEOData] Found finalized data in cache for tab ${tabId}.`);
            processDataAndSend(seoDataStore[tabId]); // Use cache directly
          } else {
            chrome.storage.local.get(`tab_${tabId}`, function(result) {
              const storedData = result[`tab_${tabId}`];
              if (storedData) {
                console.log(`[background.js getSEOData] Found finalized data in storage for tab ${tabId}.`);
                seoDataStore[tabId] = storedData; // Update cache
                processDataAndSend(storedData);
              } else {
                // No finalized data found in storage (potentially cleared by navigation)
                console.log(`[background.js getSEOData] No data found in storage for tab ${tabId}. Sending null.`);
                // Send null data to indicate it needs refresh/is invalid
                processDataAndSend(null);
              }
            }); // End of chrome.storage.local.get callback
          }
        };
        retrieveAndSendData();
      } else {
        sendResponse({ success: false, error: "No active tab found" });
      }
    });
    return true; // Keep channel open for async response from storage.local.get
  }

  // --- Fetch Server Details on Demand ---
  if (message.action === "fetchServerDetails") {
    chrome.tabs.query({active: true, currentWindow: true}, async function(tabs) {
      if (tabs && tabs.length > 0 && tabs[0].id) {
        const tabId = tabs[0].id;
        const currentTab = tabs[0];
        let serverInfoResult = { ip: 'N/A (API Error)', httpVersion: 'N/A', server: 'N/A', loaded: true };

        if (currentTab.url && (currentTab.url.startsWith('http:') || currentTab.url.startsWith('https:'))) {
          try {
            const url = new URL(currentTab.url);
            const targetDomain = url.hostname;
            const backendApiUrl = 'https://vercel-extension-backend.vercel.app/api/check-server';
            const response = await fetch(backendApiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ target: targetDomain })
             });
             if (!response.ok) throw new Error(`Backend API HTTP error! status: ${response.status}`);
             const backendData = await response.json();
             if (backendData.success) {
               serverInfoResult = {
                 ip: backendData.dns_info?.main_ip || 'N/A (No IP)',
                 httpVersion: backendData.http_info?.highest_version || 'N/A',
                 server: backendData.http_info?.server || 'N/A',
                 loaded: true
               };
               // Update stored data
               const currentData = seoDataStore[tabId] || {};
                currentData.serverInfo = serverInfoResult;
                seoDataStore[tabId] = currentData;
                const storageData = {}; storageData[`tab_${tabId}`] = currentData;
                chrome.storage.local.set(storageData, () => {
                   if (chrome.runtime.lastError) {
                      console.error(`[fetchServerDetails Tab ${tabId}] Error saving server info:`, chrome.runtime.lastError);
                   }
                   // Removed sendMessage call
                });
              } else {
               console.warn(`[fetchServerDetails Tab ${tabId}] Backend API failure:`, backendData);
               serverInfoResult.ip = `N/A (Backend: ${backendData.error || 'Failed'})`;
             }
          } catch (error) {
            console.error(`[fetchServerDetails Tab ${tabId}] Error fetching backend API:`, error);
            serverInfoResult.ip = 'N/A (Fetch Error)';
          }
        } else {
           serverInfoResult.ip = 'N/A (Invalid URL)';
        }
        sendResponse({ success: true, serverInfo: serverInfoResult });
      } else {
        sendResponse({ success: false, error: "No active tab found" });
      }
    });
    return true;
  }

  // --- Inject Web Vitals Library ---
  if (message.action === "injectWebVitals") {
    const tabId = sender.tab?.id;
    if (!tabId) return sendResponse({ success: false, error: "No sender tab ID" });
    console.log(`[background.js] Received injectWebVitals request for tab ${tabId}`);
    (async () => {
      try {
        await chrome.scripting.executeScript({ target: { tabId: tabId }, files: ['js/lib/web-vitals.iife.js'], world: 'ISOLATED' });
        console.log(`[background.js] Injected web-vitals library for tab ${tabId}`);
        sendResponse({ success: true });
      } catch (error) {
        console.error(`[background.js] Failed to inject web-vitals library for tab ${tabId}:`, error);
        sendResponse({ success: false, error: error.message });
      }
    })();
    return true;
  }

  // --- Store Web Vitals Result ---
  if (message.action === "webVitalsResult" && sender.tab && message.data) {
    const tabId = sender.tab.id;
    const { name, value } = message.data;
    if (tabId && name && typeof value === 'number') {
      console.log(`[background.js] Received webVitalsResult for tab ${tabId}:`, name, value);
      const currentData = seoDataStore[tabId] || {};
      if (!currentData.webVitals) currentData.webVitals = {};
      currentData.webVitals[name] = value;
      seoDataStore[tabId] = currentData;
      const storageData = {}; storageData[`tab_${tabId}`] = currentData;
       chrome.storage.local.set(storageData, () => {
         if (!chrome.runtime.lastError) {
           console.log(`[background.js] Successfully saved web vital ${name} for tab ${tabId}`);
           // Removed sendMessage call
         } else {
           console.error(`[background.js] Error saving web vital ${name} for tab ${tabId}:`, chrome.runtime.lastError);
         }
       });
    } else {
        console.warn("[background.js] Invalid webVitalsResult message:", message);
    }
    return; // No response needed
  }

});

// Manual trigger (optional)
chrome.action.onClicked.addListener(function(tab) {
  // Popup initiates data request
});
